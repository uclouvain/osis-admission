# ##############################################################################
#
#    OSIS stands for Open Student Information System. It's an application
#    designed to manage the core business of higher education institutions,
#    such as universities, faculties, institutes and professional schools.
#    The core business involves the administration of students, teachers,
#    courses, programs and so on.
#
#    Copyright (C) 2015-2023 UniversitÃ© catholique de Louvain (http://www.uclouvain.be)
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    A copy of this license - GNU General Public License - is available
#    at the root of the source code of this program.  If not,
#    see http://www.gnu.org/licenses/.
#
# ##############################################################################
import abc
from typing import List

from django.utils.dateparse import parse_datetime, parse_date

from admission.ddd.admission.dtos.emplacement_document import EmplacementDocumentDTO
from admission.ddd.admission.dtos.question_specifique import QuestionSpecifiqueDTO
from admission.ddd.admission.dtos.resume import ResumePropositionDTO
from admission.ddd.admission.enums.emplacement_document import (
    TypeEmplacementDocument,
    StatutEmplacementDocument,
    IdentifiantBaseEmplacementDocument,
    DocumentsSysteme,
)
from admission.exports.admission_recap.attachments import Attachment
from admission.exports.admission_recap.section import get_sections, Section
from osis_common.ddd import interface


class IEmplacementsDocumentsPropositionTranslator(interface.DomainService):
    @classmethod
    @abc.abstractmethod
    def recuperer_metadonnees_par_uuid_document(cls, uuids_documents: List[str]) -> dict:
        raise NotImplementedError

    @classmethod
    def recuperer_emplacements_dto(
        cls,
        resume_dto: ResumePropositionDTO,
        questions_specifiques: List[QuestionSpecifiqueDTO],
    ) -> List[EmplacementDocumentDTO]:
        # Get the requested documents by tab
        tabs = get_sections(
            context=resume_dto,
            specific_questions=questions_specifiques,
            with_free_requestable_documents=True,
        )

        # Get a read token and metadata of all documents
        # Add all documents that are or were requested to the candidate
        all_file_uuids = [
            file_uuid for section in tabs for attachment in section.attachments for file_uuid in attachment.uuids
        ]

        # Add the 'LIBRE' documents uploaded by the managers
        for champ_documents_libres in [
            'documents_libres_sic_candidats',
            'documents_libres_fac_candidats',
            'documents_libres_sic_uclouvain',
            'documents_libres_fac_uclouvain',
        ]:
            for document_uuid in getattr(resume_dto.proposition, champ_documents_libres):
                all_file_uuids.append(str(document_uuid))

        # Add the documents generated by the system
        system_documents = (('DOSSIER_ANALYSE', resume_dto.proposition.pdf_recapitulatif),)

        for _, document_uuids in system_documents:
            if document_uuids:
                all_file_uuids.append(str(document_uuids[0]))

        file_metadata = cls.recuperer_metadonnees_par_uuid_document(all_file_uuids)

        documents = []

        # Add all documents that are or were requested to the candidate
        for tab in tabs:
            for attachment in tab.attachments:
                document = cls.get_emplacement_document_reclamables(
                    uuid_proposition=resume_dto.proposition.uuid,
                    attachment=attachment,
                    tab=tab,
                    file_metadata=file_metadata,
                    requested_documents=resume_dto.proposition.documents_demandes,
                )
                documents.append(document)

        # Add the 'LIBRE' documents uploaded by the managers
        for document_type, document_uuids in [
            (TypeEmplacementDocument.LIBRE_CANDIDAT_FAC, resume_dto.proposition.documents_libres_fac_candidats),
            (TypeEmplacementDocument.LIBRE_CANDIDAT_SIC, resume_dto.proposition.documents_libres_sic_candidats),
            (TypeEmplacementDocument.LIBRE_INTERNE_FAC, resume_dto.proposition.documents_libres_fac_uclouvain),
            (TypeEmplacementDocument.LIBRE_INTERNE_SIC, resume_dto.proposition.documents_libres_sic_uclouvain),
        ]:
            for document_uuid in document_uuids:
                documents.append(
                    cls.get_emplacement_document_libre_non_reclamable(
                        uuid_proposition=resume_dto.proposition.uuid,
                        document_uuid=str(document_uuid),
                        document_type=document_type,
                        file_metadata=file_metadata,
                    )
                )

        # Add the documents generated by the system
        for domain_identifier, document_uuids in system_documents:
            if document_uuids:
                documents.append(
                    cls.get_emplacement_document_systeme(
                        uuid_proposition=resume_dto.proposition.uuid,
                        document_uuid=str(document_uuids[0]),
                        domain_identifier=domain_identifier,
                        file_metadata=file_metadata,
                    ),
                )

        return documents

    @classmethod
    def get_emplacement_document_reclamables(
        cls,
        uuid_proposition,
        attachment: Attachment,
        tab: Section,
        file_metadata: dict,
        requested_documents: dict,
    ) -> EmplacementDocumentDTO:
        document_id = f'{tab.identifier}.{attachment.identifier}'
        requested_document = requested_documents.get(document_id, {})
        metadata = file_metadata.get(attachment.uuids[0]) if attachment.uuids else {}
        return EmplacementDocumentDTO(
            identifiant=document_id,
            libelle=attachment.label,
            libelle_langue_candidat=attachment.candidate_language_label,
            document_uuids=attachment.uuids,
            type=requested_document['type'] if 'type' in requested_document else TypeEmplacementDocument.NON_LIBRE,
            statut=requested_document['status']
            if 'status' in requested_document
            else StatutEmplacementDocument.A_RECLAMER.name
            if (attachment.required and not attachment.uuids)
            else StatutEmplacementDocument.NON_ANALYSE.name,
            justification_gestionnaire=requested_document.get('reason'),
            reclame_le=requested_document.get('requested_at') and parse_datetime(requested_document['requested_at']),
            dernier_acteur=requested_document.get('last_actor'),
            derniere_action_le=requested_document.get('last_action_at')
            and parse_datetime(requested_document['last_action_at']),
            a_echeance_le=requested_document.get('deadline_at') and parse_date(requested_document['deadline_at']),
            onglet=tab.identifier,
            nom_onglet=tab.label,
            uuid_proposition=uuid_proposition,
            document_soumis_par=metadata.get('author'),
            document_soumis_le=metadata.get('uploaded_at') and parse_datetime(metadata['uploaded_at']),
        )

    @classmethod
    def get_emplacement_document_libre_non_reclamable(
        cls,
        uuid_proposition,
        document_uuid,
        document_type,
        file_metadata,
    ) -> EmplacementDocumentDTO:
        metadata = file_metadata.get(document_uuid)
        base_identifier = IdentifiantBaseEmplacementDocument.LIBRE_GESTIONNAIRE

        return EmplacementDocumentDTO(
            identifiant=f'{base_identifier.name}.{document_uuid}',
            libelle=metadata.get('explicit_name', ''),
            libelle_langue_candidat=metadata.get('explicit_name', ''),
            document_uuids=[document_uuid],
            type=document_type.name,
            statut=StatutEmplacementDocument.VALIDE.name,
            justification_gestionnaire='',
            document_soumis_par=metadata.get('author') or '',
            document_soumis_le=metadata.get('uploaded_at') and parse_datetime(metadata['uploaded_at']),
            reclame_le=None,
            derniere_action_le=None,
            dernier_acteur='',
            a_echeance_le=None,
            onglet=base_identifier.name,
            nom_onglet=base_identifier.value,
            uuid_proposition=uuid_proposition,
        )

    @classmethod
    def get_emplacement_document_systeme(
        cls,
        uuid_proposition,
        document_uuid,
        domain_identifier,
        file_metadata,
    ) -> EmplacementDocumentDTO:
        metadata = file_metadata.get(document_uuid)
        base_identifier = IdentifiantBaseEmplacementDocument.SYSTEME
        return EmplacementDocumentDTO(
            identifiant=f'{base_identifier.name}.{domain_identifier}',
            libelle=DocumentsSysteme['domain_identifier'],
            libelle_langue_candidat=DocumentsSysteme['domain_identifier'],
            document_uuids=[document_uuid],
            type=TypeEmplacementDocument.SYSTEME.name,
            statut=StatutEmplacementDocument.VALIDE.name,
            justification_gestionnaire='',
            document_soumis_par=metadata.get('author') or '',
            document_soumis_le=metadata.get('uploaded_at') and parse_datetime(metadata['uploaded_at']),
            reclame_le=None,
            derniere_action_le=None,
            dernier_acteur='',
            a_echeance_le=None,
            onglet=base_identifier.name,
            nom_onglet=base_identifier.value,
            uuid_proposition=uuid_proposition,
        )
